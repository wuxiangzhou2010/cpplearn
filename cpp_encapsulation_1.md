# C++远征 封装篇-上

[link](https://www.imooc.com/learn/382)

## 2-1 类和对象

- 什么是类， 什么是对象
- 类的定义： 数据成员， 成员函数
- 类的访问限定符

## 2-2 C++类对象实例化

- 实例的初始化方法 两种：
  - 栈中初始化 `ClassName var`, `ClassName var[20]`
  - 堆中初始化 `ClassName *p = new ClassName()`, `ClassName *p = new ClassName[20]` --> delete p, delete [] p
- 对象成员的访问方法 两种:
  - `.`
  - `->`

## 3-1 C++ string

- char 类型的数组， 操作复杂，有很多相关的函数 str.. strn...

- string 类型,头函数 `<string>` std 命名空间

  - 初始化方法 四种

    ```cpp
    string s1;
    string s2("abc");
    string s3(s2);
    string s4(n,'c');
    ```

- 常用操作

  - `s.empty()` `s.size()`
  - `s[n]`
  - `+`
  - `=`
  - `==`
  - `!=`

    note: 字符串`常量`之间不能直接用"+"连接

    ```cpp
    getline(cin,name);// 获取用户输入的 一行字符串
    ```

## 数据的封装

- 4-1 属性封装之初始封装

  - 面向对象的基本思想

  谁做什么， 对数据的操作转换为函数的操作

  - 封装的好处

    1. 能限制属性的访问，可以不公开， 只读属性（只写 getter 函数，不写 setter 函数）

- 数据的封装 `getter` `setter` 函数

## 5-1 类内定义与内联函数

- 类外定义--> 优先编译为内联函数
- 类外定义

  - 同文件类外定义
  - 分文件类外定义

## 6-1 构造函数

- 内存分区

  - 栈
  - 堆
  - 全局区： 存储全局变量和静态变量
  - 常量区： string str = "hello"
  - 代码区：

- 对象初始化

  - 有且仅有一次的初始化一次
  - 根据条件初始化

    使用初始化函数的问题：忘记调用初始化函数，重复调用初始化函数

- 构造函数

  - 构造函数在对象实例化时被自动调用
  - 构造函数与类同名
  - 构造函数没有返回值
  - 构造函数可以有多个重载形式
  - 实例化对象的时候仅用到一个构造函数
  - 当用户没有定义构造函数的时候，编译器自动生成一个构造函数

- 无参构造函数

  也叫默认构造函数

- 有参构造函数

  可以传入初始值

注意防止： 重载函数的调用不明确

## 构造函数初始化列表

- 6-4 默认构造函数

  实例化对象的时候不需要传递参数的构造函数成为`默认构造函数`

- 语法 `Student():m_strName("xiaohong"),m_iAge(10)();`
- 特性
  - 初始化列表先于构造函数执行
  - 初始化列表只能用于构造行数
  - 初始化列表可以同时初始化多个数据成员
- 用处
  - 常量只能通过初始化列表初始化

note: 一个类可以没有默认构造函数， 有别的构造函数也可以实例化对象。

## 6-7 拷贝构造函数

```cpp
Student(const Student& stu) {} // const 引用
```

- 如果没有自定义的拷贝构造函数则系统自动生成一个默认的拷贝构造函数
- 采用直接初始化或者复制初始化实例对象的时候自动调用拷贝构造函数

总结：

- 无参构造函数 --> 肯定是默认构造函数
- 有参构造函数

  - 参数带默认值，所有参数都有默认值则为默认构造函数
  - 参数无默认值

如果未定义系统将会自动生成的函数

- 普通构造函数
- 拷贝构造函数

对象通过参数传递的时候也会调用拷贝构造函数

note: 拷贝构造函数无法重载： 拷贝构造函数的名字和参数是确定的， 不能重载

## 6-10 析构函数

- 定义格式 `~类名()`

用处：如：销毁时释放内存/资源

总结

- 如果没有定义析构函数则系统自动生成
- 析构函数在对象销毁时自动调用
- 析构函数没有返回值，没有参数，不能重载
